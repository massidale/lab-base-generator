/*
 * LAB GENERATOR per KATHARA
 *
 * Questo programma genera automaticamente la struttura di un laboratorio Kathara
 * con configurazione per diversi tipi di macchine (router con FRR, server web, host semplici).
 *
 * Uso: ./lab_generator nome:igp[+egp]:LANs nome:igp[+egp]:LANs ...
 *      ./lab_generator host1 host2 host3  (default: nessun servizio)
 *      ./lab_generator r1:rip:ABC r2:ospf+bgp:BDE r3:both+bgp:CDE
 *
 * Tipi supportati:
 *   IGP (Interior Gateway Protocol):
 *     - rip: router con protocollo RIP
 *     - ospf: router con protocollo OSPF
 *     - both: router con entrambi i protocolli (RIP + OSPF)
 *   EGP (Exterior Gateway Protocol):
 *     - bgp: Border Gateway Protocol (usare con +, es: rip+bgp)
 *   Altri:
 *     - server: server web con Apache2
 *     - host (o vuoto): host semplice senza servizi
 *
 * Struttura generata:
 * lab/
 * ├── lab.conf                    (configurazione generale del lab)
 * ├── nome.startup                (script di avvio della macchina)
 * ├── nomeRouter/                 (solo per router rip/ospf)
 * │   └── etc/frr/
 * │       ├── daemons
 * │       └── frr.conf
 * └── nomeServer/                 (solo per server)
 *     └── var/www/html/
 *         └── index.html
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <errno.h>

/*
 * Funzione per generare il contenuto del file daemons
 * in base ai protocolli di routing scelti (IGP e/o EGP)
 *
 * Parametri:
 *   igp_protocol: stringa contenente "rip", "ospf" o "both"
 *   has_bgp: 1 se BGP è attivo, 0 altrimenti
 *
 * Ritorna:
 *   Stringa allocata dinamicamente con il contenuto del file daemons
 */
char* generate_daemons_content(const char *igp_protocol, int has_bgp) {
    char *content = malloc(2048);

    // Determina quali demoni attivare in base ai protocolli
    const char *ospfd_value = (strcmp(igp_protocol, "ospf") == 0 || strcmp(igp_protocol, "both") == 0) ? "yes" : "no";
    const char *ripd_value = (strcmp(igp_protocol, "rip") == 0 || strcmp(igp_protocol, "both") == 0) ? "yes" : "no";
    const char *bgpd_value = has_bgp ? "yes" : "no";

    snprintf(content, 2048,
        "zebra=yes\n"
        "bgpd=%s\n"
        "ospfd=%s\n"
        "ospf6d=no\n"
        "ripd=%s\n"
        "ripngd=no\n"
        "isisd=no\n"
        "pimd=no\n"
        "ldpd=no\n"
        "nhrpd=no\n"
        "eigrpd=no\n"
        "babeld=no\n"
        "sharpd=no\n"
        "staticd=no\n"
        "pbrd=no\n"
        "bfdd=no\n"
        "fabricd=no\n"
        "\n"
        "#\n"
        "# If this option is set the /etc/init.d/frr script automatically loads\n"
        "# the config via \"vtysh -b\" when the servers are started.\n"
        "# Check /etc/pam.d/frr if you intend to use \"vtysh\"!\n"
        "#\n"
        "vtysh_enable=yes\n"
        "zebra_options=\" -s 90000000 --daemon -A 127.0.0.1\"\n"
        "bgpd_options=\"   --daemon -A 127.0.0.1\"\n"
        "ospfd_options=\"  --daemon -A 127.0.0.1\"\n"
        "ospf6d_options=\" --daemon -A ::1\"\n"
        "ripd_options=\"   --daemon -A 127.0.0.1\"\n"
        "ripngd_options=\" --daemon -A ::1\"\n"
        "isisd_options=\"  --daemon -A 127.0.0.1\"\n"
        "pimd_options=\"  --daemon -A 127.0.0.1\"\n"
        "ldpd_options=\"  --daemon -A 127.0.0.1\"\n"
        "nhrpd_options=\"  --daemon -A 127.0.0.1\"\n"
        "eigrpd_options=\"  --daemon -A 127.0.0.1\"\n"
        "babeld_options=\"  --daemon -A 127.0.0.1\"\n"
        "sharpd_options=\"  --daemon -A 127.0.0.1\"\n"
        "staticd_options=\"  --daemon -A 127.0.0.1\"\n"
        "pbrd_options=\"  --daemon -A 127.0.0.1\"\n"
        "bfdd_options=\"  --daemon -A 127.0.0.1\"\n"
        "fabricd_options=\"  --daemon -A 127.0.0.1\"\n"
        "\n"
        "#MAX_FDS=1024\n"
        "# The list of daemons to watch is automatically generated by the init script.\n"
        "#watchfrr_options=\"\"\n"
        "\n"
        "# for debugging purposes, you can specify a \"wrap\" command to start instead\n"
        "# of starting the daemon directly, e.g. to use valgrind on ospfd:\n"
        "#   ospfd_wrap=\"/usr/bin/valgrind\"\n"
        "# or you can use \"all_wrap\" for all daemons, e.g. to use perf record:\n"
        "#   all_wrap=\"/usr/bin/perf record --call-graph -\"\n"
        "# the normal daemon command is added to this at the end.\n",
        bgpd_value, ospfd_value, ripd_value);

    return content;
}

/*
 * Funzione per generare il contenuto del file frr.conf
 * in base ai protocolli di routing scelti (IGP e/o EGP)
 *
 * Parametri:
 *   igp_protocol: stringa contenente "rip", "ospf" o "both"
 *   has_bgp: 1 se BGP è attivo, 0 altrimenti
 *
 * Ritorna:
 *   Stringa allocata dinamicamente con il contenuto del file frr.conf
 */
char* generate_frr_conf_content(const char *igp_protocol, int has_bgp) {
    char *content = malloc(2048);
    char bgp_config[512] = "";

    // Se BGP è attivo, aggiungi la configurazione BGP
    if (has_bgp) {
        snprintf(bgp_config, sizeof(bgp_config),
            "!\n"
            "! BGP Configuration\n"
            "!\n"
            "router bgp (TODO)\n"
            "   neighbor (TODO) remote-as (TODO)\n"
            "!\n"
            "network (TODO)\n"
            "!\n"
            "!Rimuovere il commento per utilizzare\n"
            "!no bgp network import-check\n"
            "!no bgp ebgp-requires-policy\n"
            "!\n"
            "!neighbor (TODO) prefix-list peerIn in\n"
            "!neighbor (TODO) prefix-list peerOut out\n"
            "!\n"
            "!ip prefix-list peerIn deny (TODO)\n"
            "!ip prefix-list peerIn permit (TODO)\n"
            "!\n"
            "!ip prefix-list peerOut deny (TODO)\n"
            "!ip prefix-list peerOut permit (TODO)\n"
            "!\n"
            "!neighbor (TODO) route-map prefIn in\n"
            "!route-map prefIn permit 10\n"
            "!    set local-preference 110\n"
            "!\n"
        );
    }

    if (strcmp(igp_protocol, "rip") == 0) {
        snprintf(content, 2048,
            "!\n"
            "! FRRouting configuration file\n"
            "!\n"
            "! RIP Configuration\n"
            "!\n"
            "router rip\n"
            "   network (TODO)\n"
            "!\n"
            "%s"
            "log file /var/log/frr/frr.log\n", bgp_config);
    } else if (strcmp(igp_protocol, "ospf") == 0) {
        snprintf(content, 2048,
            "!\n"
            "! FRRouting configuration file\n"
            "!\n"
            "! OSPF Configuration\n"
            "!\n"
            "router ospf\n"
            "   network (TODO) area (TODO)\n"
            "   !area (TODO) stub\n"
            "!\n"
            "!Rimuovere il commento per utilizzare\n"
            "!interface eth(TODO)\n"
            "!ospf cost (TODO)\n"
            "!\n"
            "%s"
            "log file /var/log/frr/frr.log\n", bgp_config);
    } else if (strcmp(igp_protocol, "bgp") == 0) {
        snprintf(content, 2048,
            "!\n"
            "! FRRouting configuration file\n"
            "!\n"
            "%s"
            "log file /var/log/frr/frr.log\n", bgp_config);
    } else if (strcmp(igp_protocol, "both") == 0) {
        snprintf(content, 2048,
            "!\n"
            "! FRRouting configuration file\n"
            "!\n"
            "! RIP Configuration\n"
            "router rip\n"
            "   network (TODO)\n"
            "!\n"
            "! OSPF Configuration\n"
            "!\n"
            "router ospf\n"
            "   network (TODO) area (TODO)\n"
            "   !area (TODO) stub\n"
            "!\n"
            "!Rimuovere il commento per utilizzare\n"
            "!interface eth(TODO)\n"
            "!ospf cost (TODO)\n"
            "!\n"
            "%s"
            "log file /var/log/frr/frr.log\n", bgp_config);
    }


    return content;
}

/*
 * Funzione per generare il contenuto del file .startup
 * in base al tipo di macchina (router, server, host)
 *
 * Parametri:
 *   machine_type: stringa contenente "rip", "ospf", "server" o altro
 *
 * Ritorna:
 *   Stringa allocata dinamicamente con il contenuto del file startup
 */
char* generate_startup_content(const char *machine_type, const char *lans) {
    char *content = malloc(1024);
    char interfaces[512] = "";

    // Genera configurazioni IP per ogni LAN
    int lan_count = strlen(lans);
    for (int i = 0; i < lan_count; i++) {
        char line[128];
        snprintf(line, sizeof(line), "ip address add (TODO) dev eth%d\n", i);
        strcat(interfaces, line);
    }

    // Se non ci sono LAN, metti almeno una interfaccia di default
    if (lan_count == 0) {
        strcat(interfaces, "ip address add (TODO) dev eth(TODO)\n");
    }

    if (strcmp(machine_type, "rip") == 0 || strcmp(machine_type, "ospf") == 0 || strcmp(machine_type, "both") == 0 || strcmp(machine_type, "bgp") == 0) {
        // Router con FRR
        snprintf(content, 1024,
            "%s"
            "systemctl start frr\n", interfaces);
    } else if (strcmp(machine_type, "server") == 0) {
        // Server web con Apache
        snprintf(content, 1024,
            "%s"
            "systemctl start apache2\n", interfaces);
    } else if (strcmp(machine_type, "host") == 0) {
        // Host semplice senza servizi
        snprintf(content, 1024, "%s", interfaces);
    } else {
        // Non dovrebbe mai arrivare qui grazie alla validazione
        snprintf(content, 1024, "%s", interfaces);
    }

    return content;
}

/*
 * CONTENUTO FILE INDEX.HTML per server web
 */
const char *INDEX_HTML_CONTENT =
"<!DOCTYPE html>\n"
"<html>\n"
"<head>\n"
"    <title>Kathara Web Server</title>\n"
"</head>\n"
"<body>\n"
"    <h1>Hello World</h1>\n"
"    <p>This is a Kathara lab web server.</p>\n"
"</body>\n"
"</html>\n";

/*
 * create_directory_recursive
 * Crea ricorsivamente una struttura di directory.
 *
 * Parametri:
 *   path: percorso completo della directory da creare
 *
 * Ritorna:
 *   0 se successo, -1 se errore
 *
 * Esempio: create_directory_recursive("lab/r1/etc/frr")
 * Crea: lab/, poi lab/r1/, poi lab/r1/etc/, infine lab/r1/etc/frr/
 */
int create_directory_recursive(const char *path) {
    char tmp[256];      // Buffer temporaneo per manipolare il path
    char *p = NULL;     // Puntatore per iterare attraverso il path
    size_t len;         // Lunghezza del path

    // Copia il path nel buffer temporaneo
    snprintf(tmp, sizeof(tmp), "%s", path);
    len = strlen(tmp);

    // Rimuovi slash finale se presente
    if (tmp[len - 1] == '/')
        tmp[len - 1] = 0;

    // Itera attraverso il path creando ogni directory intermedia
    for (p = tmp + 1; *p; p++) {
        if (*p == '/') {
            *p = 0;  // Termina temporaneamente la stringa

            // Crea la directory con permessi 755 (rwxr-xr-x)
            if (mkdir(tmp, 0755) != 0 && errno != EEXIST) {
                return -1;  // Errore se non riesce a creare (tranne se esiste già)
            }
            *p = '/';  // Ripristina lo slash
        }
    }

    // Crea l'ultima directory del path
    if (mkdir(tmp, 0755) != 0 && errno != EEXIST) {
        return -1;
    }

    return 0;  // Successo
}

/*
 * create_file_with_content
 * Crea un file e scrive il contenuto specificato.
 *
 * Parametri:
 *   filepath: percorso completo del file da creare
 *   content: contenuto da scrivere nel file
 *
 * Ritorna:
 *   0 se successo, -1 se errore
 */
int create_file_with_content(const char *filepath, const char *content) {
    FILE *file = fopen(filepath, "w");  // Apri il file in scrittura
    if (file == NULL) {
        return -1;  // Errore apertura file
    }
    fprintf(file, "%s", content);  // Scrivi il contenuto
    fclose(file);                  // Chiudi il file
    return 0;                       // Successo
}

/*
 * FUNZIONE MAIN
 * Punto di ingresso del programma.
 * Genera la struttura del laboratorio Kathara per i router specificati.
 */
int main(int argc, char *argv[]) {
    // Verifica che siano stati passati dei router come argomenti
    if (argc < 2) {
        printf("Uso: %s <nome[:tipo[+bgp][:lans]]> <nome[:tipo[+bgp][:lans]]> ...\n", argv[0]);
        printf("\nEsempi:\n");
        printf("  %s r1:rip:ABC r2:ospf+bgp:BD r3:both+bgp:CDE\n", argv[0]);
        printf("  %s as1r1:rip+bgp:AB as2r1:ospf+bgp:BC  (con BGP)\n", argv[0]);
        printf("  %s r1:rip r2:ospf host1:host  (senza LAN specificate)\n", argv[0]);
        printf("\nTipi supportati:\n");
        printf("  IGP (Interior Gateway Protocol):\n");
        printf("    rip    - Router con protocollo RIP\n");
        printf("    ospf   - Router con protocollo OSPF\n");
        printf("    both   - Router con RIP + OSPF\n");
        printf("    bgp    - Router con solo BGP\n");
        printf("  EGP (Exterior Gateway Protocol):\n");
        printf("    +bgp   - Aggiunge BGP a un IGP (es: rip+bgp)\n");
        printf("  Altri:\n");
        printf("    server - Server web con Apache2\n");
        printf("    host   - Host semplice senza servizi\n");
        return 1;
    }

    // STEP 1: Crea la cartella principale del laboratorio
    if (create_directory_recursive("lab") != 0) {
        perror("Errore creando cartella lab");
        return 1;
    }

    // STEP 2: Processa ogni macchina passata come argomento
    for (int i = 1; i < argc; i++) {
        char path[512];     // Buffer per i percorsi delle directory
        char filepath[512]; // Buffer per i percorsi dei file
        char machine_name[256];  // Nome della macchina
        char machine_type[32] = "";  // Tipo di macchina (IGP o server/host)
        char lans[256] = "";  // LAN di collisione
        int has_bgp = 0;  // Flag per BGP

        // Parsing del formato nome:tipo[+bgp]:lans
        char *arg_copy = strdup(argv[i]);
        char *first_colon = strchr(arg_copy, ':');

        if (first_colon != NULL) {
            // Estrai nome macchina
            size_t name_len = first_colon - arg_copy;
            strncpy(machine_name, arg_copy, name_len);
            machine_name[name_len] = '\0';

            // Cerca secondo ':' per le LAN
            char *second_colon = strchr(first_colon + 1, ':');
            char type_str[64];

            if (second_colon != NULL) {
                // Formato nome:tipo:lans
                size_t type_len = second_colon - first_colon - 1;
                strncpy(type_str, first_colon + 1, type_len);
                type_str[type_len] = '\0';
                strcpy(lans, second_colon + 1);
            } else {
                // Formato nome:tipo (senza LAN)
                strcpy(type_str, first_colon + 1);
            }

            // Controlla se c'è +bgp nel tipo
            char *plus = strchr(type_str, '+');
            if (plus != NULL) {
                *plus = '\0';  // Termina la stringa al '+'
                strcpy(machine_type, type_str);
                // Verifica che dopo '+' ci sia 'bgp'
                if (strcmp(plus + 1, "bgp") == 0) {
                    has_bgp = 1;
                } else {
                    fprintf(stderr, "\nErrore: EGP '%s' non riconosciuto per macchina %s (solo 'bgp' supportato)\n", plus + 1, machine_name);
                    free(arg_copy);
                    continue;
                }
            } else {
                strcpy(machine_type, type_str);
                if (strcmp(machine_type, "bgp") == 0) {
                    has_bgp = 1;
                }
            }
        } else {
            // Solo nome macchina
            strcpy(machine_name, arg_copy);
        }

        free(arg_copy);

        // Valida il tipo di macchina
        if (strlen(machine_type) > 0) {
            if (strcmp(machine_type, "rip") != 0 &&
                strcmp(machine_type, "ospf") != 0 &&
                strcmp(machine_type, "both") != 0 &&
                strcmp(machine_type, "bgp") != 0 &&
                strcmp(machine_type, "server") != 0 &&
                strcmp(machine_type, "host") != 0) {
                fprintf(stderr, "\nErrore: tipo '%s' non riconosciuto per macchina %s\n", machine_type, machine_name);
                fprintf(stderr, "Tipi validi: rip, ospf, both, bgp, server, host\n");
                continue;
            }
        } else {
            // Se non è specificato un tipo, usa "host" come default
            strcpy(machine_type, "host");
        }

        printf("\nConfigurando macchina: %s con tipo: %s", machine_name, machine_type);
        if (has_bgp) {
            printf("+bgp");
        }
        if (strlen(lans) > 0) {
            printf(" - LAN: %s\n", lans);
        } else {
            printf("\n");
        }

        // STEP 2.1: Crea struttura directory e file in base al tipo di macchina
        if (strcmp(machine_type, "rip") == 0 || strcmp(machine_type, "ospf") == 0 || strcmp(machine_type, "both") == 0 || strcmp(machine_type, "bgp") == 0) {
            // ROUTER: Crea struttura FRR
            snprintf(path, sizeof(path), "lab/%s/etc/frr", machine_name);
            if (create_directory_recursive(path) != 0) {
                fprintf(stderr, "Errore creando cartella per router %s\n", machine_name);
                continue;
            }

            // Crea file daemons
            snprintf(filepath, sizeof(filepath), "lab/%s/etc/frr/daemons", machine_name);
            char *daemons_content = generate_daemons_content(machine_type, has_bgp);
            if (create_file_with_content(filepath, daemons_content) != 0) {
                fprintf(stderr, "Errore creando file daemons per router %s\n", machine_name);
            } else {
                printf("  Creato: %s\n", filepath);
            }
            free(daemons_content);

            // Crea file frr.conf
            snprintf(filepath, sizeof(filepath), "lab/%s/etc/frr/frr.conf", machine_name);
            char *frr_conf_content = generate_frr_conf_content(machine_type, has_bgp);
            if (create_file_with_content(filepath, frr_conf_content) != 0) {
                fprintf(stderr, "Errore creando file frr.conf per router %s\n", machine_name);
            } else {
                printf("  Creato: %s\n", filepath);
            }
            free(frr_conf_content);

        } else if (strcmp(machine_type, "server") == 0) {
            // SERVER: Crea struttura Apache
            snprintf(path, sizeof(path), "lab/%s/var/www/html", machine_name);
            if (create_directory_recursive(path) != 0) {
                fprintf(stderr, "Errore creando cartella per server %s\n", machine_name);
                continue;
            }

            // Crea file index.html
            snprintf(filepath, sizeof(filepath), "lab/%s/var/www/html/index.html", machine_name);
            if (create_file_with_content(filepath, INDEX_HTML_CONTENT) != 0) {
                fprintf(stderr, "Errore creando file index.html per server %s\n", machine_name);
            } else {
                printf("  Creato: %s\n", filepath);
            }
        }
        // Per host semplici non creiamo cartelle aggiuntive

        // STEP 2.2: Crea il file .startup con i comandi di inizializzazione
        snprintf(filepath, sizeof(filepath), "lab/%s.startup", machine_name);
        char *startup_content = generate_startup_content(machine_type, lans);
        if (create_file_with_content(filepath, startup_content) != 0) {
            fprintf(stderr, "Errore creando file .startup per macchina %s\n", machine_name);
        } else {
            printf("  Creato: %s\n", filepath);
        }
        free(startup_content);
    }  // Fine del ciclo per ogni router

    // STEP 3: Crea il file lab.conf con la configurazione generale del laboratorio
    // Questo file definisce per ogni router:
    // - [0]: la LAN a cui è connesso (da completare con TODO)
    // - [image]: l'immagine Docker da usare (kathara/frr)
    FILE *labconf = fopen("lab/lab.conf", "w");
    if (labconf == NULL) {
        fprintf(stderr, "Errore creando file lab.conf\n");
    } else {
        // Genera una entry per ogni macchina
        for (int i = 1; i < argc; i++) {
            // Estrai nome macchina e LAN
            char machine_name[256];
            char lans[256] = "";
            char *arg_copy = strdup(argv[i]);
            char *first_colon = strchr(arg_copy, ':');

            if (first_colon != NULL) {
                // Estrai nome
                size_t name_len = first_colon - arg_copy;
                strncpy(machine_name, arg_copy, name_len);
                machine_name[name_len] = '\0';

                // Cerca LAN dopo il secondo ':'
                char *second_colon = strchr(first_colon + 1, ':');
                if (second_colon != NULL) {
                    strcpy(lans, second_colon + 1);
                }
            } else {
                strcpy(machine_name, arg_copy);
            }

            // Scrivi configurazione LAN nel lab.conf
            if (strlen(lans) > 0) {
                for (int j = 0; j < strlen(lans); j++) {
                    fprintf(labconf, "%s[%d]=%c\n", machine_name, j, lans[j]);
                }
            } else {
                fprintf(labconf, "%s[0]=(TODO)\n", machine_name);
            }

            fprintf(labconf, "%s[image]=\"kathara/frr\"\n", machine_name);

            free(arg_copy);

            // Aggiungi riga vuota tra le macchine (tranne l'ultima)
            if (i < argc - 1) {
                fprintf(labconf, "\n");
            }
        }
        fclose(labconf);
        printf("Creato: lab/lab.conf\n");
    }

    // STEP 4: Stampa messaggio di completamento e istruzioni
    printf("\n✓ Struttura del lab creata con successo!\n");

    return 0;  // Termina con successo
}