/*
 * LAB GENERATOR per KATHARA
 *
 * Questo programma genera automaticamente la struttura di un laboratorio Kathara
 * con configurazione per diversi tipi di macchine (router con FRR, server web, host semplici).
 *
 * Uso: ./lab_generator nome:tipo nome:tipo ...
 *      ./lab_generator r1 r2 r3  (default: nessun servizio)
 *
 * Tipi supportati:
 *   - rip: router con protocollo RIP
 *   - ospf: router con protocollo OSPF
 *   - both: router con entrambi i protocolli (RIP + OSPF)
 *   - server: server web con Apache2
 *   - (vuoto o altro): host semplice senza servizi
 *
 * Struttura generata:
 * lab/
 * ├── lab.conf                    (configurazione generale del lab)
 * ├── nome.startup                (script di avvio della macchina)
 * ├── nomeRouter/                 (solo per router rip/ospf)
 * │   └── etc/frr/
 * │       ├── daemons
 * │       └── frr.conf
 * └── nomeServer/                 (solo per server)
 *     └── var/www/html/
 *         └── index.html
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <errno.h>

/*
 * Funzione per generare il contenuto del file daemons
 * in base al protocollo di routing scelto (RIP o OSPF)
 *
 * Parametri:
 *   protocol: stringa contenente "rip" o "ospf"
 *
 * Ritorna:
 *   Stringa allocata dinamicamente con il contenuto del file daemons
 */
char* generate_daemons_content(const char *protocol) {
    char *content = malloc(2048);

    // Determina quale demone attivare in base al protocollo
    const char *ospfd_value = (strcmp(protocol, "ospf") == 0 || strcmp(protocol, "both") == 0) ? "yes" : "no";
    const char *ripd_value = (strcmp(protocol, "rip") == 0 || strcmp(protocol, "both") == 0) ? "yes" : "no";

    snprintf(content, 2048,
        "zebra=yes\n"
        "bgpd=no\n"
        "ospfd=%s\n"
        "ospf6d=no\n"
        "ripd=%s\n"
        "ripngd=no\n"
        "isisd=no\n"
        "pimd=no\n"
        "ldpd=no\n"
        "nhrpd=no\n"
        "eigrpd=no\n"
        "babeld=no\n"
        "sharpd=no\n"
        "staticd=no\n"
        "pbrd=no\n"
        "bfdd=no\n"
        "fabricd=no\n"
        "\n"
        "#\n"
        "# If this option is set the /etc/init.d/frr script automatically loads\n"
        "# the config via \"vtysh -b\" when the servers are started.\n"
        "# Check /etc/pam.d/frr if you intend to use \"vtysh\"!\n"
        "#\n"
        "vtysh_enable=yes\n"
        "zebra_options=\" -s 90000000 --daemon -A 127.0.0.1\"\n"
        "bgpd_options=\"   --daemon -A 127.0.0.1\"\n"
        "ospfd_options=\"  --daemon -A 127.0.0.1\"\n"
        "ospf6d_options=\" --daemon -A ::1\"\n"
        "ripd_options=\"   --daemon -A 127.0.0.1\"\n"
        "ripngd_options=\" --daemon -A ::1\"\n"
        "isisd_options=\"  --daemon -A 127.0.0.1\"\n"
        "pimd_options=\"  --daemon -A 127.0.0.1\"\n"
        "ldpd_options=\"  --daemon -A 127.0.0.1\"\n"
        "nhrpd_options=\"  --daemon -A 127.0.0.1\"\n"
        "eigrpd_options=\"  --daemon -A 127.0.0.1\"\n"
        "babeld_options=\"  --daemon -A 127.0.0.1\"\n"
        "sharpd_options=\"  --daemon -A 127.0.0.1\"\n"
        "staticd_options=\"  --daemon -A 127.0.0.1\"\n"
        "pbrd_options=\"  --daemon -A 127.0.0.1\"\n"
        "bfdd_options=\"  --daemon -A 127.0.0.1\"\n"
        "fabricd_options=\"  --daemon -A 127.0.0.1\"\n"
        "\n"
        "#MAX_FDS=1024\n"
        "# The list of daemons to watch is automatically generated by the init script.\n"
        "#watchfrr_options=\"\"\n"
        "\n"
        "# for debugging purposes, you can specify a \"wrap\" command to start instead\n"
        "# of starting the daemon directly, e.g. to use valgrind on ospfd:\n"
        "#   ospfd_wrap=\"/usr/bin/valgrind\"\n"
        "# or you can use \"all_wrap\" for all daemons, e.g. to use perf record:\n"
        "#   all_wrap=\"/usr/bin/perf record --call-graph -\"\n"
        "# the normal daemon command is added to this at the end.\n",
        ospfd_value, ripd_value);

    return content;
}

/*
 * Funzione per generare il contenuto del file frr.conf
 * in base al protocollo di routing scelto (RIP o OSPF)
 *
 * Parametri:
 *   protocol: stringa contenente "rip" o "ospf"
 *
 * Ritorna:
 *   Stringa allocata dinamicamente con il contenuto del file frr.conf
 */
char* generate_frr_conf_content(const char *protocol) {
    char *content = malloc(1024);

    if (strcmp(protocol, "rip") == 0) {
        snprintf(content, 1024,
            "!\n"
            "! FRRouting configuration file\n"
            "!\n"
            "router rip\n"
            "network (TODO)\n"
            "!\n"
            "log file /var/log/frr/frr.log\n");
    } else if (strcmp(protocol, "ospf") == 0) {
        snprintf(content, 1024,
            "!\n"
            "! FRRouting configuration file\n"
            "!\n"
            "router ospf\n"
            "network (TODO) area (TODO)\n"
            "!!!area (TODO) stub"
            "!\n"
            "!!!interface eth(TODO)\n"
            "!!!ospf cost (TODO)\n"
            "!\n"
            "log file /var/log/frr/frr.log\n");
    } else if (strcmp(protocol, "both") == 0) {
        snprintf(content, 1024,
            "!\n"
            "! FRRouting configuration file\n"
            "!\n"
            "! RIP Configuration\n"
            "router rip\n"
            "network (TODO)\n"
            "!\n"
            "! OSPF Configuration\n"
            "router ospf\n"
            "network (TODO) area (TODO)\n"
            "!\n"
            "!interface eth(TODO)\n"
            "!ospf cost (TODO)\n"
            "!\n"
            "log file /var/log/frr/frr.log\n");
    }


    return content;
}

/*
 * Funzione per generare il contenuto del file .startup
 * in base al tipo di macchina (router, server, host)
 *
 * Parametri:
 *   machine_type: stringa contenente "rip", "ospf", "server" o altro
 *
 * Ritorna:
 *   Stringa allocata dinamicamente con il contenuto del file startup
 */
char* generate_startup_content(const char *machine_type) {
    char *content = malloc(256);

    if (strcmp(machine_type, "rip") == 0 || strcmp(machine_type, "ospf") == 0 || strcmp(machine_type, "both") == 0) {
        // Router con FRR
        snprintf(content, 256,
            "ip address add (TODO) dev eth(TODO)\n"
            "systemctl start frr\n");
    } else if (strcmp(machine_type, "server") == 0) {
        // Server web con Apache
        snprintf(content, 256,
            "ip address add (TODO) dev eth(TODO)\n"
            "systemctl start apache2\n");
    } else {
        // Host semplice senza servizi
        snprintf(content, 256,
            "ip address add (TODO) dev eth(TODO)\n");
    }

    return content;
}

/*
 * CONTENUTO FILE INDEX.HTML per server web
 */
const char *INDEX_HTML_CONTENT =
"<!DOCTYPE html>\n"
"<html>\n"
"<head>\n"
"    <title>Kathara Web Server</title>\n"
"</head>\n"
"<body>\n"
"    <h1>Hello World</h1>\n"
"    <p>This is a Kathara lab web server.</p>\n"
"</body>\n"
"</html>\n";

/*
 * create_directory_recursive
 * Crea ricorsivamente una struttura di directory.
 *
 * Parametri:
 *   path: percorso completo della directory da creare
 *
 * Ritorna:
 *   0 se successo, -1 se errore
 *
 * Esempio: create_directory_recursive("lab/r1/etc/frr")
 * Crea: lab/, poi lab/r1/, poi lab/r1/etc/, infine lab/r1/etc/frr/
 */
int create_directory_recursive(const char *path) {
    char tmp[256];      // Buffer temporaneo per manipolare il path
    char *p = NULL;     // Puntatore per iterare attraverso il path
    size_t len;         // Lunghezza del path

    // Copia il path nel buffer temporaneo
    snprintf(tmp, sizeof(tmp), "%s", path);
    len = strlen(tmp);

    // Rimuovi slash finale se presente
    if (tmp[len - 1] == '/')
        tmp[len - 1] = 0;

    // Itera attraverso il path creando ogni directory intermedia
    for (p = tmp + 1; *p; p++) {
        if (*p == '/') {
            *p = 0;  // Termina temporaneamente la stringa

            // Crea la directory con permessi 755 (rwxr-xr-x)
            if (mkdir(tmp, 0755) != 0 && errno != EEXIST) {
                return -1;  // Errore se non riesce a creare (tranne se esiste già)
            }
            *p = '/';  // Ripristina lo slash
        }
    }

    // Crea l'ultima directory del path
    if (mkdir(tmp, 0755) != 0 && errno != EEXIST) {
        return -1;
    }

    return 0;  // Successo
}

/*
 * create_file_with_content
 * Crea un file e scrive il contenuto specificato.
 *
 * Parametri:
 *   filepath: percorso completo del file da creare
 *   content: contenuto da scrivere nel file
 *
 * Ritorna:
 *   0 se successo, -1 se errore
 */
int create_file_with_content(const char *filepath, const char *content) {
    FILE *file = fopen(filepath, "w");  // Apri il file in scrittura
    if (file == NULL) {
        return -1;  // Errore apertura file
    }
    fprintf(file, "%s", content);  // Scrivi il contenuto
    fclose(file);                  // Chiudi il file
    return 0;                       // Successo
}

/*
 * FUNZIONE MAIN
 * Punto di ingresso del programma.
 * Genera la struttura del laboratorio Kathara per i router specificati.
 */
int main(int argc, char *argv[]) {
    // Verifica che siano stati passati dei router come argomenti
    if (argc < 2) {
        printf("Uso: %s <nome[:tipo]> <nome[:tipo]> ...\n", argv[0]);
        printf("\nEsempi:\n");
        printf("  %s r1:rip r2:ospf server1:server host1\n", argv[0]);
        printf("  %s r1 r2 r3  (host semplici senza servizi)\n", argv[0]);
        printf("\nTipi supportati:\n");
        printf("  rip    - Router con protocollo RIP\n");
        printf("  ospf   - Router con protocollo OSPF\n");
        printf("  both   - Router con entrambi i protocolli (RIP + OSPF)\n");
        printf("  server - Server web con Apache2\n");
        printf("  (vuoto)- Host semplice senza servizi\n");
        return 1;
    }

    // STEP 1: Crea la cartella principale del laboratorio
    if (create_directory_recursive("lab") != 0) {
        perror("Errore creando cartella lab");
        return 1;
    }

    // STEP 2: Processa ogni macchina passata come argomento
    for (int i = 1; i < argc; i++) {
        char path[512];     // Buffer per i percorsi delle directory
        char filepath[512]; // Buffer per i percorsi dei file
        char machine_name[256];  // Nome della macchina
        char machine_type[32] = "";  // Tipo di macchina (vuoto = host semplice)

        // Parsing del nome macchina e tipo (formato: nome:tipo)
        char *colon = strchr(argv[i], ':');
        if (colon != NULL) {
            // Estrai nome macchina e tipo
            size_t name_len = colon - argv[i];
            strncpy(machine_name, argv[i], name_len);
            machine_name[name_len] = '\0';
            strcpy(machine_type, colon + 1);
        } else {
            // Solo nome macchina, nessun tipo specifico (host semplice)
            strcpy(machine_name, argv[i]);
        }

        printf("\nConfigurando macchina: %s", machine_name);
        if (strlen(machine_type) > 0) {
            printf(" con tipo: %s\n", machine_type);
        } else {
            printf(" (host semplice)\n");
        }

        // STEP 2.1: Crea struttura directory e file in base al tipo di macchina
        if (strcmp(machine_type, "rip") == 0 || strcmp(machine_type, "ospf") == 0 || strcmp(machine_type, "both") == 0) {
            // ROUTER: Crea struttura FRR
            snprintf(path, sizeof(path), "lab/%s/etc/frr", machine_name);
            if (create_directory_recursive(path) != 0) {
                fprintf(stderr, "Errore creando cartella per router %s\n", machine_name);
                continue;
            }

            // Crea file daemons
            snprintf(filepath, sizeof(filepath), "lab/%s/etc/frr/daemons", machine_name);
            char *daemons_content = generate_daemons_content(machine_type);
            if (create_file_with_content(filepath, daemons_content) != 0) {
                fprintf(stderr, "Errore creando file daemons per router %s\n", machine_name);
            } else {
                printf("  Creato: %s\n", filepath);
            }
            free(daemons_content);

            // Crea file frr.conf
            snprintf(filepath, sizeof(filepath), "lab/%s/etc/frr/frr.conf", machine_name);
            char *frr_conf_content = generate_frr_conf_content(machine_type);
            if (create_file_with_content(filepath, frr_conf_content) != 0) {
                fprintf(stderr, "Errore creando file frr.conf per router %s\n", machine_name);
            } else {
                printf("  Creato: %s\n", filepath);
            }
            free(frr_conf_content);

        } else if (strcmp(machine_type, "server") == 0) {
            // SERVER: Crea struttura Apache
            snprintf(path, sizeof(path), "lab/%s/var/www/html", machine_name);
            if (create_directory_recursive(path) != 0) {
                fprintf(stderr, "Errore creando cartella per server %s\n", machine_name);
                continue;
            }

            // Crea file index.html
            snprintf(filepath, sizeof(filepath), "lab/%s/var/www/html/index.html", machine_name);
            if (create_file_with_content(filepath, INDEX_HTML_CONTENT) != 0) {
                fprintf(stderr, "Errore creando file index.html per server %s\n", machine_name);
            } else {
                printf("  Creato: %s\n", filepath);
            }
        }
        // Per host semplici non creiamo cartelle aggiuntive

        // STEP 2.2: Crea il file .startup con i comandi di inizializzazione
        snprintf(filepath, sizeof(filepath), "lab/%s.startup", machine_name);
        char *startup_content = generate_startup_content(machine_type);
        if (create_file_with_content(filepath, startup_content) != 0) {
            fprintf(stderr, "Errore creando file .startup per macchina %s\n", machine_name);
        } else {
            printf("  Creato: %s\n", filepath);
        }
        free(startup_content);
    }  // Fine del ciclo per ogni router

    // STEP 3: Crea il file lab.conf con la configurazione generale del laboratorio
    // Questo file definisce per ogni router:
    // - [0]: la LAN a cui è connesso (da completare con TODO)
    // - [image]: l'immagine Docker da usare (kathara/frr)
    FILE *labconf = fopen("lab/lab.conf", "w");
    if (labconf == NULL) {
        fprintf(stderr, "Errore creando file lab.conf\n");
    } else {
        // Genera una entry per ogni router
        for (int i = 1; i < argc; i++) {
            // Estrai solo il nome del router (prima del ':')
            char router_name[256];
            char *colon = strchr(argv[i], ':');
            if (colon != NULL) {
                size_t name_len = colon - argv[i];
                strncpy(router_name, argv[i], name_len);
                router_name[name_len] = '\0';
            } else {
                strcpy(router_name, argv[i]);
            }

            fprintf(labconf, "%s[0]=(TODO)\n", router_name);      // LAN del router
            fprintf(labconf, "%s[image]=\"kathara/frr\"\n", router_name); // Immagine Docker

            // Aggiungi riga vuota tra i router (tranne l'ultimo)
            if (i < argc - 1) {
                fprintf(labconf, "\n");
            }
        }
        fclose(labconf);
        printf("Creato: lab/lab.conf\n");
    }

    // STEP 4: Stampa messaggio di completamento e istruzioni
    printf("\n✓ Struttura del lab creata con successo!\n");
    printf("\nPer compilare: gcc -o lab_generator lab_generator.c\n");
    printf("Per eseguire: ./lab_generator r1 r2 r3\n");

    return 0;  // Termina con successo
}